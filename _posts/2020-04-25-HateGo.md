---
layout: post
title: I Hate Golang (and You Should Too)!
tags: [programming, rant]
featured_image_thumbnail: Gopher
featured_image: assets/images/posts/2020/04/gopher.jpg
featured: true
hidden: false
---

It's easy to say "I like this" or "I don't like that".
It can be difficult to form an argument for *why* you feel that way.
I've been using the Go programming language for my graduate Distributed Systems course,
and I'd love to share why I have come to despise this popular language.

## Un-Struct-ured

Consider a struct reference in C.
Suppose we have a `Cat` struct.

```c
struct Cat {
    int lives;
}
```

We can access the cat's field `doesPurr` by using the `.` operator.

```c
int main() { 
    struct Cat kitty;
    kitty.lives = 9;
}
```

If we have a reference to cat, we can access the cat's field variable one of two ways.
We can derefence the reference and modify the field, or we can access the field with the `->` operator.
Both accomplish the same goal, and both are shown below.

```c
int main() {
    struct Cat *kittyPtr = &kitty;
    (*kittyPtr).lives = 8; // The tradition
    kittyPtr->lives = 7; // The "syntactic sugar"
}
```

Although C can be somewhat archaic, it is *explicitly* clear if we are dealing with either a cat or a *reference to* a cat.
Let's consider the same idea in Go.
Similarly, here is our cat struct.
Again, we can use the `.` operator to access and set a field.

```go
package main

import "fmt"

type Cat struct {
    lives int
}

func main() {
    kitty := Cat{}
    kitty.lives = 9
}
```

We can still get a reference to our cat.

```go
...

func main() {
    kitty := Cat{}
    kittyPtr := &kitty
}
```

Nothing seems wrong... yet.
What happens if we want to change the cat's number of lives?
That snippet of code would be as follows.

```go
...

func main() {
    kitty := Cat{lives: 9}
    kitty.lives = 9 // Access by .
    kittyPtr := &kitty
    kittyPtr.lives = 9 // Access by .
}
```

Whoa!
In an effort to reduce strain for programmers, Go does not make a syntactic distinction between the `Cat` and the `*Cat`.
However, there is a **huge** difference between the two.
*This drives me crazy!*
This abstraction does not provide an understanding of *what you are actually doing* when you write code, and that's a problem.  


## Too Many Assignments

I've spoken with developers who love to return more than one value.
I try not to do that, but I understand that it certainly can be useful.
Go alllows you to return multiple values.
Alreadty, I'm not a happy camper, but that's just a personal choice,

While Java utilizes an exception-throwing system which can be handled sooner or later,
I've noticed Go paradigms tend to return errors in those multiple-valued returns.
Suppose we have some function that returns an integer and an error.

```go
func tryFunc() (result int, error err) {...}
```

Suppose we called that function.

```go
result, err := tryFunc()
```

There is absolutely nothing wrong with this.
Now, what happens if we call it a second time?

```go
result1, err := tryFunc()
result2, err := tryFunc()
```

What's wrong here?
We cannot use an assignment of `=` for the second line because we have not 
It's unclear what we are doing, but we are reassigning a value to `err`.
This may seem fine, but there's a lot of information that can be lost if many statements are added in between these two lines of code.

Now, it's important to remember that the short variable declaration operator (`:=`) is a way to [quickly and implicitly assign a value to a variable](https://golang.org/ref/spec#Short_variable_declarations).
Unfortunately, it's a much better idea to mostly use immutable values and only use mutable variables when you absolutely have to.
My first programming language was Python, and when I was first introduced to this concept, I thought it was absurd.
Modern languages such as Swift and Rust leverage constants for speed.
Go tries to help its developers (which is why people love it), but it is instead only encouraging bad habits.


## Get Your Priorities Straight

While working on a Distributed Systems lab, my parter had handed me a commit with an obscure compile warning:
"loop variable i captured by func literal".
I never would have been able to understand it (I do not find the Go compiler to be very helpful for troubleshooting),
but I was fortuante enough to find [this awesome post which explained it perfectly](https://stackoverflow.com/a/58151372).
To illustrate my point, the code looked something like this.

```go
for i := 0; i < 10; i++ {
    go func(){
        doSomethingWith(i)
    }()
}
```

It is supposed to look like this.

```go
for i := 0; i < 10; i++ {
    go func(anotherI){
        doSomethingWith(anotherI)
    }(i)
}
```

Of course, the "proper" code would be something more like the following.

```go
for i := 0; i < 10; i++ {
    doSomethingWith(i)
}
```

This is an incredibly important detail which should not be overlooked.
Though it's not good form to modify a global variable, it is entirely possible that `doSomethingWith(...)` could.
The second block of code (the right way) explicitly prevents the go function from modifying the loop variable `i`.
Then, why is this only worth a compile *warning*?

Don't you find it annoying that even a picky language like Rust will only warn you about an unused variable, 
yet Go will throw a compile error?
This is completely bass-ackwards!
In fact, it's *absurd*!


## Conclusion

I do not enjoy programming in Go.
I can sit down and quickly write something,
but many of the language's nuances are incredibly concerning to me.  
